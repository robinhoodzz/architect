# 微服务

## 概述

### 微服务优缺点

* 优点
  1. 聚焦业务, 松耦合
  2. 开发简单, 效率高
  3. 方便部署和维护
* 缺点
  1. 增加系统间通信成本
  2. 数据一致性问题, 分布式事务问题
  3. 服务数量增加, 运维压力增大
     1. 故障定位难
     2. 容量预估难
     3. 资源浪费多
     4. 链路梳理难



### Dubbo vs Springcloud

|              | dubbo      | springcloud | 结果      |
| ------------ | ---------- | ----------- | --------- |
| 背景         | 国内影响大 | 世界影响大  | cloud胜出 |
| 社区活跃程度 | 低         | 高          | cloud胜出 |
| 架构完整度   | 不完善     | 相对完善    | cloud胜出 |
| 学习成本     | 需要学习   | 无缝spring  | cloud胜出 |



### 技术选型

* dubbo

  * zookeeper + dubbo + springmvc/springboot
  * 通信方式: rpc
  * 注册中心: zookeeper
  * 配置中心: xdiamond

* spring cloud

  * spring + netfilx
  * 通信方式: http restful
  * 注册中心: eureka
  * 配置中心: config
  * 断路器: hystrix
  * 网关: zuul
  * 分布式追踪系统: sleuth + zipkin

  



### 软件项目流程

* 需求采集, 分析, 筛选等前期过程(决定做不做, 做多少)
* 确定需求负责人, 需求状态变 "需求中"
* 项目 kick off
  * 开发
    * 确定开发计划(确定何时做, 谁做)
    * 设计
    * 设计评审
    * 编码
  * 产品
    * 需求评审(决定怎么做)
    * 需求确认
  * 测试
    * TC编写
    * TC评审
    * 测试
    * 确认发布



## 注册中心 Eureka

### 注册中心的作用

* 面向对象的一个重要设计原则
  * 迪米特法则, (最少知识原则), 一个对象应当对其他对象有尽可能少的了解, 不和陌生人说话
* 提供服务注册/发现的功能, 作用在降低服务之间的耦合与发现成本
* 角色有, 注册中心, 服务提供者, 服务消费者
  * 提供者的功能
    * 注册 register
    * 续约 renew
    * 下线 cancel
  * 注册中心
    * 对消费者: 获取注册列表 
    * 对提供者: 维护注册列表
  * 消费者
    * 获取提供者的真实URL
    * 发起远程调用





### eureka客户端启动生命周期

* 启动过程
  1. 读取自己配置文件中, 与注册中心交互
  2. 读取自身的配置信息
  3. 从eureka端拉取信息, 并缓存到本地, 全量拉取
  4. 服务注册到eureka
  5. 初始3个定时任务
* 运行
  * 定时发送心跳到eureka, 维持在eureka上的租约renew
  * 从eureka拉去注册表信息, 并更新到本地缓存,  增量拉取
  * 监控自身的变化, 如有变动, 再重新注册
* 销毁
  * 销毁在eureka上自己的租约



### 启动时的关键类

* EurekaClientAutoConfiguration
  * 关键bean的初始化
* RibbonEurekaAutoConfiguration
  * 加载负载均衡相关的配置
* EurekaDiscoveryClientConfiguration
  * 配置自动注册的
* DiscoveryClient
  * 实现与eureka交互的相关逻辑
  * 注册,续约,下线,获取注册列表



### Eureka服务端接收注册的流程

* 当client注册时, 先获取读锁
* 在注册表中查询 instanceInfo, 这个对象是client发给eureka注册中心的
* 判断逻辑: 租约是否存在
  * 不存在: 创建新的租约
  * 存在:     判断最后更新时间与接收到instanceInfo的时间谁更晚(时间戳谁更大), 避免老的服务把新的服务替换掉
    * 接收包时间戳 < 服务最后更新时间戳,  什么都不做
    * 接收包时间戳 > 服务最后更新时间戳,  更新为接收包的时间戳, 并设置上限时间(为了计算租约的有效性)
* 释放锁



### Eureka服务接收心跳

* 心跳的前提是, 在eureka已经有租约了

* 心跳过来时, 先查询租约, 若不存在则不管了
* 判断状态
  * unknown 的状态, 则取消续约
  * 正常状态, 更新租约时间
* 统计每分钟续约次数, 用于自我保护



### 服务剔除

* AbstractInstanceRegistry#evict
* 自我保护时, 不允许剔除, !isLeaseExpirationEnabled()
* 计算到期的租约集合, 并统计数量
  * 总注册量 - (总注册量 * 阈值) = 极限值
  * 过期租约数量 > 极限值, 则触发剔除
* 随机找租约过期的, 进行剔除操作, internalCancel



### 服务下线

* 查找是否有租约
  * 无: 下线失败
  * 有: 注册表中移除
* 设置下线时间
* 添加下线记录, 用于给其他client端拉取





### 集群同步

* 总计2个过程
  * 启动
    * 从peer(同辈)拉取信息
    * 把信息注册到自己的本地注册表中
  * 启动后, 有client到我这里注册时, 通过XXX方法到其他节点
    * PeerAwareInstanceRegistryImpl#cancel中的replicateToPeers方法



### 注册中心总结

> 由于集群间的同步复制是通过http的方式进行的, 基于网络的不可靠性, 集群中的Eureka server间的注册表信息难免存在不同步的时间节点, 不满足CAP中的C(数据一致性)





### 服务调用

* 思考: 调用如何做? 要手动配置每一个服务的IP,PORT,URL和参数吗?
* 朴素的硬编码, 成千上万, 成本高, 累死了, 也不能解耦, 最好就像调用本地方法一样的去调用
* cloud提供2种调用方式: ribbon和feign
* 区别在于一个是 客户端的负载均衡, 另一个是 服务端的负载均衡
  * 进一步说: 服务器地址列表的存储位置
  * ribbon feign 都是 客户端负载均衡
  * 服务端的负载均衡有: nginx lvs
* 默认采用RoundRobinRule: 轮询负载均衡策略
* 面试题: http和restful区别
  * 资源表现层状态转移
  * Representational State Transfer
  * 通过http的动作, 来完成RESTful
  * 客户端访问过程中必然涉及**数据和状态的转化**, 客户端想操作服务端资源, 必须通过某种手段, 让服务器端资源发生**状态的转移**. 这个过程建立在表现层之上, 被称之为***表层状态转移***. 客户端通过使用http协议中的**四个动词**实现上述操作, 分别是: 获取资源的GET, 新建或更新资源的POST, 更新资源的PUT, 删除资源的DELETE



### ribbon



### feign 原理

* FeignServiceClient这样的被@FeignClient注解修饰的接口, 如何创建, 也就是其Bean实例是如何被创建的
* 调用FeignServiceClient对象的网络请求相关的函数时, OpenFeign是如何发送网络请求的
* @EnableFeignClient的作用
  1. 引入FeignClientsRegister
  2. 指定扫描FeignClient的包信息,就是指定FeignClient接口类所在的包名
  3. 指定FeignClient接口类的自定义配置类
* 与Ribbon的区别
  * feign.SynchronousMethodHandler#invoke是个动态代理, 方法里代理了restTemplate的创建



### 服务雪崩

* 本次内存调用与远程调用最大的不同在于: 远程调用可能失败, 可能延迟/挂起, 直到达到超时时间
* 当很多调用者调用无法响应的服务时, 可能导致严重的***级联故障(cascading failures)***, 尤其是分布式系统中.



### 熔断hystrix

* 解决的问题:
  * 在分布式系统中, 一个服务依赖多个服务, 可能存在某个服务调用失败, 比如超时, 异常, 如果保证在某些服务故障时, 对整个服务没有影响
  * hystrix, 熔断器, 出现错误后用fallback返回错误的处理信息, 或者兜底数据
* 熔断与降级的区别
  * 熔断: 为隔离服务调用者和异常服务提供者防止服务雪崩效应, 提供了一种保护措施
    * 多次失败, 而被暂时性忽略, 短期内不再使用
  * 降级: 为了整体资源不够的时候, 适当放弃部分服务, 将主要的资源投放到核心服务中, 待度过难关后, 再重
    * 主逻辑失败而采取的备用逻辑方案
  * 启已经关闭的服务, 保证了系统核心服务的稳定
  * 共同点: 
    1. 为了方式服务崩溃, 保证主要功能的可用性和可靠性
    2. 用户体验到某些功能不可用
  * 不同点
    1. 熔断由下级故障触发, 主动惹祸
    2. 降级由调用方从负荷角度触发, 无辜被抛弃
* 开关
  * client通过断路器(保险丝)去调用server, 断路器的状态有3个, 关闭(正常), 打开(不去调用server), 半开
  * 关闭
    * client调用server, server响应正常
    * client调用server失败, 没有达到阈值, 达到阈值后进入打开状态
  * 打开
    * client调用server时, 会先通过熔断器, 此时熔断器工作, 不向server发送请求, 直接返回失败(触发回调函数, 客户端自行处理)
    * 时间窗口后, 断路器处于半开状态
  * 半开
    * 此时允许调用, 当调用成功的比例达到阈值后, 进入关闭状态, 恢复正常



### 网关介绍以及应用场景

* 为什么要用网关?
  * 客户端会多次请求不同的微服务, 增加了客户端复杂性
  * 认证复杂, 每个服务要独立认证
  * 难以重构, 多个服务可能将会合并成一个或拆分成多个
  * 安全性, 微服务不需要向外暴露, 通过物理网络隔离
* 增加***封装和隔离性***
  * 微服务组成的内网不想将接口全部暴露给外部服务
  * 通过网关做一层封装, 暴露有限的接口
* 功能
  * 统一接入: 智能路由, AB测试, 灰度测试, 日志埋点
  * 流量监控: 限流处理
  * 安全防护: 鉴权, 网络物理隔离
* 



### 链路追踪 Zipkin

* 解决错综复杂的服务调用中链路的查看, 排查慢服务
* 最朴素的方式: 通过前后调用时间戳
* 链路追踪通过流水号跟踪链路
* 日志格式
  * [服务名-traceID-spanID, false]
  * traceID
    * 一条请求流水号
  * spanID
    * 基本的工作单元, 获取数据等等
  * false
    * 是否让zipkin收集和展示此信息
* zipkin是一个大规模的APM工具(application performance manager), 基于Google Dapper(大规模分布式跟踪系统)的基础实现, 和sleuth结合可以提供可视化web界面, 分析调用链路的情况
* 连理追踪sleuth+zipkin
  * sleuth收集跟踪信息通过http请求发送给zipkin server, zipkin将跟踪信息存储, 以及提供restful api接口, zipkin ui通过调用api进行数据展示
  * 默认内存存储, 也可以用mysql, ES等存储
* 











